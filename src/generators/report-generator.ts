import * as fs from 'fs-extra';
import * as path from 'path';
import { AnalysisReport, OutputFormat } from '../types';

export class ReportGenerator {
  constructor(private outputDir: string) {}

  public async generateReports(
    report: AnalysisReport,
    formats: OutputFormat[] = ['json', 'md']
  ): Promise<string[]> {
    const generatedFiles: string[] = [];

    await fs.ensureDir(this.outputDir);

    for (const format of formats) {
      const filePath = await this.generateReport(report, format);
      generatedFiles.push(filePath);
    }

    return generatedFiles;
  }

  private async generateReport(report: AnalysisReport, format: OutputFormat): Promise<string> {
    switch (format) {
      case 'json':
        return this.generateJSONReport(report);
      case 'md':
        return this.generateMarkdownReport(report);
      case 'tsv':
        return this.generateTSVReport(report);
      case 'csv':
        return this.generateCSVReport(report);
      default:
        throw new Error(`Unsupported format: ${format}`);
    }
  }

  private async getUniqueFilePath(
    baseName: string,
    extension: string,
    force: boolean
  ): Promise<string> {
    let filePath = path.join(this.outputDir, `${baseName}.${extension}`);

    if (force || !(await fs.pathExists(filePath))) {
      return filePath;
    }

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    filePath = path.join(this.outputDir, `${baseName}-${timestamp}.${extension}`);

    return filePath;
  }

  private async generateJSONReport(
    report: AnalysisReport,
    force: boolean = false
  ): Promise<string> {
    const filePath = await this.getUniqueFilePath('analysis-report', 'json', force);
    await fs.writeFile(filePath, JSON.stringify(report, null, 2));
    return filePath;
  }

  private async generateMarkdownReport(
    report: AnalysisReport,
    force: boolean = false
  ): Promise<string> {
    const filePath = await this.getUniqueFilePath('analysis-report', 'md', force);

    const markdown = `# Next.js Code Analysis Report

## 📊 Executive Summary

- **Project**: ${report.metadata.projectRoot}
- **Next.js Version**: ${report.metadata.nextVersion}
- **Router Type**: ${report.metadata.routerType}
- **Analysis Date**: ${new Date(report.metadata.analysisDate).toLocaleDateString()}
- **Analysis Time**: ${new Date(report.metadata.analysisDate).toLocaleTimeString()}
- **Total Files Analyzed**: ${report.metadata.totalFiles}
- **Total Components**: ${report.metadata.totalComponents}
- **Total API Endpoints**: ${report.metadata.totalApiEndpoints}

## 🎯 Key Findings

### Unused Files
- **Count**: ${report.summary.unusedFiles}
- **Potential Bundle Size Savings**: ${this.formatBytes(report.summary.potentialSavings.estimatedBundleSize)}

### Dead Code
- **Count**: ${report.summary.deadCode}

### Redundant APIs
- **Count**: ${report.summary.redundantApis}

## 🗂️ File Analysis

### Unused Files (${report.files.filter((f) => f.classification === 'UNUSED').length})

${this.generateFileTable(report.files.filter((f) => f.classification === 'UNUSED'))}

### Dead Code (${report.files.filter((f) => f.classification === 'DEAD_CODE').length})

${this.generateFileTable(report.files.filter((f) => f.classification === 'DEAD_CODE'))}

## 🔌 API Analysis

### Unused APIs (${report.apiEndpoints.filter((api) => api.classification === 'UNUSED').length})

${this.generateAPITable(report.apiEndpoints.filter((api) => api.classification === 'UNUSED'))}

## 💡 Recommendations

${report.recommendations
  .map(
    (rec) =>
      `### ${rec.type}: ${rec.target}
- **Confidence**: ${rec.confidence}%
- **Impact**: ${rec.impact}
- **Description**: ${rec.description}
- **Actions**: 
${rec.actions.map((action) => `  - \`${action}\``).join('\n')}
`
  )
  .join('\n')}

## 🏗️ Dependency Graph

### Entry Points
${report.graph.entryPoints.map((ep) => `- ${ep.name} (${ep.path})`).join('\n')}

### Orphaned Components (${report.graph.orphans.length})
${report.graph.orphans.map((orphan) => `- ${orphan.name} (${orphan.path})`).join('\n')}

### Circular Dependencies (${report.graph.cycles.length})
${report.graph.cycles
  .map(
    (cycle, index) =>
      `#### Cycle ${index + 1}
${cycle.map((node) => `- ${node.name}`).join(' → ')} → ${cycle[0].name}
`
  )
  .join('\n')}

## 📈 Safe Deletions

The following files can be safely deleted with high confidence:

${report.summary.safeDeletions.map((file) => `- \`${file}\``).join('\n')}

---

*Report generated by Next.js Analyzer on ${new Date().toLocaleString()}*
`;

    await fs.writeFile(filePath, markdown);
    return filePath;
  }

  private generateFileTable(files: any[]): string {
    if (files.length === 0) {
      return '_No files found in this category._';
    }

    const headers = '| File | Type | Confidence | Reasons |';
    const separator = '|------|------|------------|---------|';

    const rows = files.map((file) => {
      const relativePath = path.relative(process.cwd(), file.path);
      return `| \`${relativePath}\` | ${file.type} | ${file.confidence}% | ${file.reasons.join(', ')} |`;
    });

    return [headers, separator, ...rows].join('\n');
  }

  private generateAPITable(apis: any[]): string {
    if (apis.length === 0) {
      return '_No APIs found in this category._';
    }

    const headers = '| API Path | Methods | File | Confidence | Reasons |';
    const separator = '|----------|---------|------|------------|---------|';

    const rows = apis.map((api) => {
      const relativePath = path.relative(process.cwd(), api.filePath);
      return `| \`${api.path}\` | ${api.methods.join(', ')} | \`${relativePath}\` | ${api.confidence}% | ${api.reasons.join(', ')} |`;
    });

    return [headers, separator, ...rows].join('\n');
  }

  private async generateTSVReport(report: AnalysisReport, force: boolean = false): Promise<string> {
    const filePath = await this.getUniqueFilePath('analysis-report', 'tsv', force);

    const headers = ['Type', 'Path', 'UsageCount', 'Classification', 'Confidence', 'Reasons'].join(
      '\t'
    );
    const rows = [headers];

    // Add file data
    report.files.forEach((file) => {
      const relativePath = path.relative(process.cwd(), file.path);
      rows.push(
        [
          'File',
          relativePath,
          file.usageLocations.length.toString(),
          file.classification,
          file.confidence.toString(),
          file.reasons.join('; '),
        ].join('\t')
      );
    });

    // Add API data
    report.apiEndpoints.forEach((api) => {
      const relativePath = path.relative(process.cwd(), api.filePath);
      rows.push(
        [
          'API',
          `${api.path} (${relativePath})`,
          api.callSites.length.toString(),
          api.classification,
          api.confidence.toString(),
          api.reasons.join('; '),
        ].join('\t')
      );
    });

    await fs.writeFile(filePath, rows.join('\n'));
    return filePath;
  }

  private async generateCSVReport(report: AnalysisReport, force: boolean = false): Promise<string> {
    const filePath = await this.getUniqueFilePath('analysis-report', 'csv', force);

    const escapeCSV = (value: string): string => {
      if (value.includes(',') || value.includes('"') || value.includes('\n')) {
        return `"${value.replace(/"/g, '""')}"`;
      }
      return value;
    };

    const headers = ['Type', 'Path', 'UsageCount', 'Classification', 'Confidence', 'Reasons']
      .map(escapeCSV)
      .join(',');
    const rows = [headers];

    // Add file data
    report.files.forEach((file) => {
      const relativePath = path.relative(process.cwd(), file.path);
      rows.push(
        [
          'File',
          relativePath,
          file.usageLocations.length.toString(),
          file.classification,
          file.confidence.toString(),
          file.reasons.join('; '),
        ]
          .map(escapeCSV)
          .join(',')
      );
    });

    // Add API data
    report.apiEndpoints.forEach((api) => {
      const relativePath = path.relative(process.cwd(), api.filePath);
      rows.push(
        [
          'API',
          `${api.path} (${relativePath})`,
          api.callSites.length.toString(),
          api.classification,
          api.confidence.toString(),
          api.reasons.join('; '),
        ]
          .map(escapeCSV)
          .join(',')
      );
    });

    await fs.writeFile(filePath, rows.join('\n'));
    return filePath;
  }

  private formatBytes(bytes: number): string {
    if (bytes === 0) return '0 Bytes';

    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }
}
