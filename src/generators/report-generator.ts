import * as fs from 'fs-extra';
import * as path from 'path';
import { AnalysisReport, OutputFormat } from '../types';

export class ReportGenerator {
  constructor(private outputDir: string) {}

  public async generateReports(
    report: AnalysisReport,
    formats: OutputFormat[] = ['json', 'md']
  ): Promise<string[]> {
    const generatedFiles: string[] = [];

    await fs.ensureDir(this.outputDir);

    for (const format of formats) {
      const filePath = await this.generateReport(report, format);
      generatedFiles.push(filePath);
    }

    return generatedFiles;
  }

  private async generateReport(report: AnalysisReport, format: OutputFormat): Promise<string> {
    switch (format) {
      case 'json':
        return this.generateJSONReport(report);
      case 'md':
        return this.generateMarkdownReport(report);
      case 'tsv':
        return this.generateTSVReport(report);
      case 'csv':
        return this.generateCSVReport(report);
      default:
        throw new Error(`Unsupported format: ${format}`);
    }
  }

  private async getUniqueFilePath(
    baseName: string,
    extension: string,
    force: boolean // Keep parameter for backward compatibility
  ): Promise<string> {
    // Always include timestamp for better report tracking and to avoid overwrites
    const now = new Date();
    const timestamp = now.toISOString().slice(0, 19).replace(/[:.]/g, '-'); // YYYY-MM-DDTHH-MM-SS format
    const filePath = path.join(this.outputDir, `${baseName}-${timestamp}.${extension}`);

    return filePath;
  }

  private async generateJSONReport(
    report: AnalysisReport,
    force: boolean = false
  ): Promise<string> {
    const filePath = await this.getUniqueFilePath('analysis-report', 'json', force);
    await fs.writeFile(filePath, JSON.stringify(report, null, 2));
    return filePath;
  }

  private async generateMarkdownReport(
    report: AnalysisReport,
    force: boolean = false
  ): Promise<string> {
    const filePath = await this.getUniqueFilePath('analysis-report', 'md', force);

    const markdown = `# Next.js Code Analysis Report

## ðŸ“Š Executive Summary

- **Project**: ${report.metadata.projectRoot}
- **Next.js Version**: ${report.metadata.nextVersion}
- **Router Type**: ${report.metadata.routerType}
- **Analysis Date**: ${new Date(report.metadata.analysisDate).toLocaleDateString()}
- **Analysis Time**: ${new Date(report.metadata.analysisDate).toLocaleTimeString()}
- **Total Files Analyzed**: ${report.metadata.totalFiles}
- **Total Components**: ${report.metadata.totalComponents}
- **Total API Endpoints**: ${report.metadata.totalApiEndpoints}

${this.generateNextJSHealthSection(report)}

## ðŸŽ¯ Key Findings

### Unused Files
- **Count**: ${report.summary.unusedFiles}
- **Potential Bundle Size Savings**: ${this.formatBytes(report.summary.potentialSavings.estimatedBundleSize)}

### Dead Code
- **Count**: ${report.summary.deadCode}

### Redundant APIs
- **Count**: ${report.summary.redundantApis}

## ðŸ—‚ï¸ File Analysis

### Unused Files (${report.files.filter((f) => f.classification === 'UNUSED').length})

${this.generateFileTable(report.files.filter((f) => f.classification === 'UNUSED'))}

### Dead Code (${report.files.filter((f) => f.classification === 'DEAD_CODE').length})

${this.generateFileTable(report.files.filter((f) => f.classification === 'DEAD_CODE'))}

## ðŸ”Œ API Analysis

### Unused APIs (${report.apiEndpoints.filter((api) => api.classification === 'UNUSED').length})

${this.generateAPITable(report.apiEndpoints.filter((api) => api.classification === 'UNUSED'))}

## ðŸ’¡ Recommendations

${report.recommendations
  .map(
    (rec) =>
      `### ${rec.type}: ${rec.target}
- **Confidence**: ${rec.confidence}%
- **Impact**: ${rec.impact}
- **Description**: ${rec.description}
- **Actions**: 
${rec.actions.map((action) => `  - \`${action}\``).join('\n')}
`
  )
  .join('\n')}

## ðŸ—ï¸ Dependency Graph

### Entry Points
${report.graph.entryPoints.map((ep) => `- ${ep.name} (${ep.path})`).join('\n')}

### Orphaned Components (${report.graph.orphans.length})
${report.graph.orphans.map((orphan) => `- ${orphan.name} (${orphan.path})`).join('\n')}

### Circular Dependencies (${report.graph.cycles.length})
${report.graph.cycles
  .map(
    (cycle, index) =>
      `#### Cycle ${index + 1}
${cycle.map((node) => `- ${node.name}`).join(' â†’ ')} â†’ ${cycle[0].name}
`
  )
  .join('\n')}

## ðŸ“ˆ Safe Deletions

The following files can be safely deleted with high confidence:

${report.summary.safeDeletions.map((file) => `- \`${file}\``).join('\n')}

---

*Report generated by Next.js Analyzer on ${new Date().toLocaleString()}*
`;

    await fs.writeFile(filePath, markdown);
    return filePath;
  }

  private generateNextJSHealthSection(report: AnalysisReport): string {
    if (!report.nextjsAnalysis) return '';

    const { projectHealth, patterns, packages, setupIssues } = report.nextjsAnalysis;

    let section = `## ðŸ¥ Next.js Project Health Score: ${projectHealth.score}/100

### âœ… Strengths
${projectHealth.strengths.map((strength) => `- ${strength}`).join('\n')}

### ðŸ”§ Areas for Improvement
${projectHealth.improvements.map((improvement) => `- ${improvement}`).join('\n')}

`;

    // Advanced Routing Patterns
    if (patterns.length > 0) {
      section += `### ðŸ›¤ï¸  Advanced Routing Patterns

| Pattern Type | Path | Purpose | Status |
|--------------|------|---------|--------|
${patterns
  .map(
    (pattern) =>
      `| ${pattern.type} | \`${pattern.path}\` | ${pattern.purpose} | ${pattern.isValid ? 'âœ…' : 'âŒ'} |`
  )
  .join('\n')}

`;
    }

    // Package Analysis
    const installedPackages = packages.filter((p) => p.installed);
    if (installedPackages.length > 0) {
      section += `### ðŸ“¦ Next.js Ecosystem Packages

| Package | Version | Setup Status | Purpose |
|---------|---------|--------------|---------|
${installedPackages
  .map(
    (pkg) =>
      `| \`${pkg.name}\` | ${pkg.version || 'N/A'} | ${this.getStatusIcon(pkg.setupStatus)} ${pkg.setupStatus} | ${pkg.purpose} |`
  )
  .join('\n')}

`;
    }

    // Setup Issues
    if (setupIssues.length > 0) {
      const errorIssues = setupIssues.filter((i) => i.severity === 'error');
      const warningIssues = setupIssues.filter((i) => i.severity === 'warning');
      const infoIssues = setupIssues.filter((i) => i.severity === 'info');

      section += `### âš ï¸  Setup Issues & Recommendations

`;

      if (errorIssues.length > 0) {
        section += `#### ðŸš¨ Critical Issues (${errorIssues.length})
${errorIssues
  .map(
    (issue) => `
**${issue.title}**
${issue.description}

Recommendations:
${issue.recommendations.map((rec) => `- ${rec}`).join('\n')}
`
  )
  .join('\n')}

`;
      }

      if (warningIssues.length > 0) {
        section += `#### âš ï¸  Warnings (${warningIssues.length})
${warningIssues
  .map(
    (issue) => `
**${issue.title}**
${issue.description}

Recommendations:
${issue.recommendations.map((rec) => `- ${rec}`).join('\n')}
`
  )
  .join('\n')}

`;
      }

      if (infoIssues.length > 0) {
        section += `#### â„¹ï¸  Optimization Opportunities (${infoIssues.length})
${infoIssues
  .map(
    (issue) => `
**${issue.title}**
${issue.description}

Recommendations:
${issue.recommendations.map((rec) => `- ${rec}`).join('\n')}
`
  )
  .join('\n')}

`;
      }
    }

    return section;
  }

  private getStatusIcon(status: string): string {
    switch (status) {
      case 'complete':
        return 'âœ…';
      case 'partial':
        return 'âš ï¸';
      case 'missing':
        return 'âŒ';
      case 'misconfigured':
        return 'ðŸ”§';
      default:
        return 'â“';
    }
  }

  private generateFileTable(files: any[]): string {
    if (files.length === 0) {
      return '_No files found in this category._';
    }

    const headers = '| File | Type | Confidence | Reasons |';
    const separator = '|------|------|------------|---------|';

    const rows = files.map((file) => {
      const relativePath = path.relative(process.cwd(), file.path);
      return `| \`${relativePath}\` | ${file.type} | ${file.confidence}% | ${file.reasons.join(', ')} |`;
    });

    return [headers, separator, ...rows].join('\n');
  }

  private generateAPITable(apis: any[]): string {
    if (apis.length === 0) {
      return '_No APIs found in this category._';
    }

    const headers = '| API Path | Methods | File | Confidence | Reasons |';
    const separator = '|----------|---------|------|------------|---------|';

    const rows = apis.map((api) => {
      const relativePath = path.relative(process.cwd(), api.filePath);
      return `| \`${api.path}\` | ${api.methods.join(', ')} | \`${relativePath}\` | ${api.confidence}% | ${api.reasons.join(', ')} |`;
    });

    return [headers, separator, ...rows].join('\n');
  }

  private async generateTSVReport(report: AnalysisReport, force: boolean = false): Promise<string> {
    const filePath = await this.getUniqueFilePath('analysis-report', 'tsv', force);

    const headers = ['Type', 'Path', 'UsageCount', 'Classification', 'Confidence', 'Reasons'].join(
      '\t'
    );
    const rows = [headers];

    // Add file data
    report.files.forEach((file) => {
      const relativePath = path.relative(process.cwd(), file.path);
      rows.push(
        [
          'File',
          relativePath,
          file.usageLocations.length.toString(),
          file.classification,
          file.confidence.toString(),
          file.reasons.join('; '),
        ].join('\t')
      );
    });

    // Add API data
    report.apiEndpoints.forEach((api) => {
      const relativePath = path.relative(process.cwd(), api.filePath);
      rows.push(
        [
          'API',
          `${api.path} (${relativePath})`,
          api.callSites.length.toString(),
          api.classification,
          api.confidence.toString(),
          api.reasons.join('; '),
        ].join('\t')
      );
    });

    await fs.writeFile(filePath, rows.join('\n'));
    return filePath;
  }

  private async generateCSVReport(report: AnalysisReport, force: boolean = false): Promise<string> {
    const filePath = await this.getUniqueFilePath('analysis-report', 'csv', force);

    const escapeCSV = (value: string): string => {
      if (value.includes(',') || value.includes('"') || value.includes('\n')) {
        return `"${value.replace(/"/g, '""')}"`;
      }
      return value;
    };

    const headers = ['Type', 'Path', 'UsageCount', 'Classification', 'Confidence', 'Reasons']
      .map(escapeCSV)
      .join(',');
    const rows = [headers];

    // Add file data
    report.files.forEach((file) => {
      const relativePath = path.relative(process.cwd(), file.path);
      rows.push(
        [
          'File',
          relativePath,
          file.usageLocations.length.toString(),
          file.classification,
          file.confidence.toString(),
          file.reasons.join('; '),
        ]
          .map(escapeCSV)
          .join(',')
      );
    });

    // Add API data
    report.apiEndpoints.forEach((api) => {
      const relativePath = path.relative(process.cwd(), api.filePath);
      rows.push(
        [
          'API',
          `${api.path} (${relativePath})`,
          api.callSites.length.toString(),
          api.classification,
          api.confidence.toString(),
          api.reasons.join('; '),
        ]
          .map(escapeCSV)
          .join(',')
      );
    });

    await fs.writeFile(filePath, rows.join('\n'));
    return filePath;
  }

  private formatBytes(bytes: number): string {
    if (bytes === 0) return '0 Bytes';

    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }
}
